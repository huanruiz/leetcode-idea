# leetcode-idea

# Tree
## Traversal
When traversing a binary tree, there are two main approaches: recursive method or using a stack/queue structure.

Recursive traversal of a binary tree can be done in three orders: Preorder, Inorder, and Postorder. Preorder is a top-down traversal, postorder is a bottom-up traversal, and inorder is typically used for traversing binary search trees.

When utilizing a stack/queue structure, the initial determination is whether to employ breadth-first search (BFS) or depth-first search (DFS). If BFS is chosen, a queue is used, whereas a stack is employed for DFS.

| # | Title | Solution | Difficulty |
|---| ----- | -------- | ---------- |
|297|[Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)|[Java](./algorithm/java/q297_serialize_and_deserialize_binary_tree/SerializeAndDeserializeBinaryTree.java)|Hard|
|226|[Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)|[Java](./algorithm/java/q226_invert_binary_tree/InvertBinaryTree.java)|Easy|
|114|[Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)|[Java](./algorithm/java/q114_flatten_binary_tree_to_linked_list/FlattenBinaryTreeToLinkedList.java)|Medium|
|116|[Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)|[Java](./algorithm/java/q116_populating_next_right_pointers_in_each_node/PopulatingNextRightPointersInEachNode.java)|Medium|
|654|[Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/)|[Java](./algorithm/java/q654_maximum_binary_tree/MaximumBinaryTree.java)|Medium|
|105|[ConstructBinaryTreeFromPreorderAndInorderTraversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)|[Java](./algorithm/java/q_construct_binary_tree_from_preorder_and_inorder_traversal/ConstructBinaryTreeFromPreorderAndInorderTraversal.java)|Medium|

## BST